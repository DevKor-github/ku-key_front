/* tslint:disable */
/* eslint-disable */
/**
 * KU-KEY API
 * API for KU-KEY service
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base'

// @ts-ignore
import { ChangePasswordRequestDto } from '../models'
// @ts-ignore
import { ChangePasswordResponseDto } from '../models'
// @ts-ignore
import { CheckPossibleResponseDto } from '../models'
// @ts-ignore
import { GetScreenshotVerificationsResponseDto } from '../models'
// @ts-ignore
import { JwtTokenDto } from '../models'
// @ts-ignore
import { LoginRequestDto } from '../models'
// @ts-ignore
import { LoginResponseDto } from '../models'
// @ts-ignore
import { LogoutRequestDto } from '../models'
// @ts-ignore
import { LogoutResponseDto } from '../models'
// @ts-ignore
import { PasswordDto } from '../models'
// @ts-ignore
import { SendTempPasswordRequestDto } from '../models'
// @ts-ignore
import { SendTempPasswordResponseDto } from '../models'
// @ts-ignore
import { SignUpResponseDto } from '../models'
// @ts-ignore
import { VerificationRequestDto } from '../models'
// @ts-ignore
import { VerificationResponseDto } from '../models'
// @ts-ignore
import { VerifyEmailRequestDto } from '../models'
// @ts-ignore
import { VerifyEmailResponseDto } from '../models'
// @ts-ignore
import { VerifyScreenshotRequestDto } from '../models'
// @ts-ignore
import { VerifyScreenshotResponseDto } from '../models'
/**
 * AuthApi - axios parameter creator
 * @export
 */
/**
 * 승인 대기 중인 학교 인증 요청 목록을 조회합니다.
 * @summary 학교인증 요청 목록 조회
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authAdminRequestGetAxiosParamCreator = async (
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/admin/request`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 학교 인증 요청을 승인 혹은 거절합니다.
 * @summary 학교인증 요청 승인/거절
 * @param {number} id
 * @param {VerifyScreenshotRequestDto} verifyScreenshotRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authAdminRequestIdPostAxiosParamCreator = async (
  id: number,
  verifyScreenshotRequestDto: VerifyScreenshotRequestDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/admin/request/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = verifyScreenshotRequestDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 요청한 email을 사용하는 유저가 있는지 확인합니다.
 * @summary email 중복 확인
 * @param {string} email 중복확인하고자 하는 email
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authEmailEmailPostAxiosParamCreator = async (
  email: string,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/email/{email}`.replace(`{${'email'}}`, encodeURIComponent(String(email)))
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 유저가 인증이 되었는지 확인합니다.
 * @summary 인증 여부 확인
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authIsVerifiedGetAxiosParamCreator = async (
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/is-verified`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 로그인하여 JWT Token을 발급받습니다.         Access Token의 만료기간은 5분이고 Refresh Token의 만료기간은 로그인 유지가 참일 경우 14일, 아닐 경우 2일입니다.
 * @summary 로그인
 * @param {LoginRequestDto} loginRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authLoginPostAxiosParamCreator = async (
  loginRequestDto: LoginRequestDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/login`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = loginRequestDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 서버에 저장된 Refresh Token을 삭제합니다.
 * @summary 로그아웃
 * @param {LogoutRequestDto} logoutRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authLogoutPostAxiosParamCreator = async (
  logoutRequestDto: LogoutRequestDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/logout`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = logoutRequestDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 사용자의 비밀번호를 변경합니다.
 * @summary 비밀번호 변경
 * @param {ChangePasswordRequestDto} changePasswordRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authPasswordPatchAxiosParamCreator = async (
  changePasswordRequestDto: ChangePasswordRequestDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/password`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = changePasswordRequestDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 저장된 비밀번호가 맞는지 확인합니다.
 * @summary 비밀번호 확인
 * @param {PasswordDto} passwordDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authPasswordPostAxiosParamCreator = async (
  passwordDto: PasswordDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/password`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = passwordDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * Refresh Token을 사용하여 Access Token과 Refresh Token을 재발급받습니다.
 * @summary Token 재발급
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authRefreshPostAxiosParamCreator = async (
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/refresh`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 이메일로 인증번호를 발송합니다.
 * @summary 이메일 인증번호 발송
 * @param {VerificationRequestDto} verificationRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authRequestEmailVerificationPostAxiosParamCreator = async (
  verificationRequestDto: VerificationRequestDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/request-email-verification`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = verificationRequestDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 유저정보를 생성하고 학교인증 요청을 발송합니다.
 * @summary 회원가입 및 학교인증 요청
 * @param {string} email 인증완료된 사용자 이메일
 * @param {string} password 사용자 비밀번호
 * @param {string} username 중복확인 완료된 userId
 * @param {string} name 본명
 * @param {string} country 국적
 * @param {string} homeUniversity 모교
 * @param {string} major 전공
 * @param {number} studentNumber 중복확인 완료된 학번
 * @param {any} screenshot 교환학생 합격 스크린샷 파일
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authSignUpPostAxiosParamCreator = async (
  email: string,
  password: string,
  username: string,
  name: string,
  country: string,
  homeUniversity: string,
  major: string,
  studentNumber: number,
  screenshot: any,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/sign-up`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any
  const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

  if (email !== undefined) {
    localVarFormParams.append('email', email as any)
  }

  if (password !== undefined) {
    localVarFormParams.append('password', password as any)
  }

  if (username !== undefined) {
    localVarFormParams.append('username', username as any)
  }

  if (name !== undefined) {
    localVarFormParams.append('name', name as any)
  }

  if (country !== undefined) {
    localVarFormParams.append('country', country as any)
  }

  if (homeUniversity !== undefined) {
    localVarFormParams.append('homeUniversity', homeUniversity as any)
  }

  if (major !== undefined) {
    localVarFormParams.append('major', major as any)
  }

  if (studentNumber !== undefined) {
    localVarFormParams.append('studentNumber', studentNumber as any)
  }

  if (screenshot !== undefined) {
    localVarFormParams.append('screenshot', screenshot as any)
  }

  localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = localVarFormParams

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 요청한 학번으로 인증된 유저가 있는지 확인합니다.
 * @summary 학번 중복 확인
 * @param {number} studentNumber 중복확인하고자 하는 학번
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authStudentNumberStudentNumberPostAxiosParamCreator = async (
  studentNumber: number,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/student-number/{studentNumber}`.replace(
    `{${'studentNumber'}}`,
    encodeURIComponent(String(studentNumber)),
  )
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 임시비밀번호를 발급하여 이메일로 발송합니다.
 * @summary 임시비밀번호 발급
 * @param {SendTempPasswordRequestDto} sendTempPasswordRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authTemporaryPasswordPostAxiosParamCreator = async (
  sendTempPasswordRequestDto: SendTempPasswordRequestDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/temporary-password`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = sendTempPasswordRequestDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 요청한 username을 사용하는 유저가 있는지 확인합니다.
 * @summary username 중복 확인
 * @param {string} username 중복확인하고자 하는 username
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authUsernameUsernamePostAxiosParamCreator = async (
  username: string,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/username/{username}`.replace(`{${'username'}}`, encodeURIComponent(String(username)))
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 발송된 인증번호로 이메일을 인증합니다.
 * @summary 이메일 인증
 * @param {VerifyEmailRequestDto} verifyEmailRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authVerifyEmailPostAxiosParamCreator = async (
  verifyEmailRequestDto: VerifyEmailRequestDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/auth/verify-email`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = verifyEmailRequestDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
/**
 * 승인 대기 중인 학교 인증 요청 목록을 조회합니다.
 * @summary 학교인증 요청 목록 조회
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authAdminRequestGetFp = async (
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<
  (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetScreenshotVerificationsResponseDto>>
> => {
  const localVarAxiosArgs = await authAdminRequestGetAxiosParamCreator(options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 학교 인증 요청을 승인 혹은 거절합니다.
 * @summary 학교인증 요청 승인/거절
 * @param {number} id
 * @param {VerifyScreenshotRequestDto} verifyScreenshotRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authAdminRequestIdPostFp = async (
  id: number,
  verifyScreenshotRequestDto: VerifyScreenshotRequestDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyScreenshotResponseDto>> => {
  const localVarAxiosArgs = await authAdminRequestIdPostAxiosParamCreator(
    id,
    verifyScreenshotRequestDto,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 요청한 email을 사용하는 유저가 있는지 확인합니다.
 * @summary email 중복 확인
 * @param {string} email 중복확인하고자 하는 email
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authEmailEmailPostFp = async (
  email: string,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPossibleResponseDto>> => {
  const localVarAxiosArgs = await authEmailEmailPostAxiosParamCreator(email, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 유저가 인증이 되었는지 확인합니다.
 * @summary 인증 여부 확인
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authIsVerifiedGetFp = async (
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> => {
  const localVarAxiosArgs = await authIsVerifiedGetAxiosParamCreator(options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 로그인하여 JWT Token을 발급받습니다.         Access Token의 만료기간은 5분이고 Refresh Token의 만료기간은 로그인 유지가 참일 경우 14일, 아닐 경우 2일입니다.
 * @summary 로그인
 * @param {LoginRequestDto} loginRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authLoginPostFp = async (
  loginRequestDto: LoginRequestDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseDto>> => {
  const localVarAxiosArgs = await authLoginPostAxiosParamCreator(loginRequestDto, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 서버에 저장된 Refresh Token을 삭제합니다.
 * @summary 로그아웃
 * @param {LogoutRequestDto} logoutRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authLogoutPostFp = async (
  logoutRequestDto: LogoutRequestDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponseDto>> => {
  const localVarAxiosArgs = await authLogoutPostAxiosParamCreator(logoutRequestDto, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 사용자의 비밀번호를 변경합니다.
 * @summary 비밀번호 변경
 * @param {ChangePasswordRequestDto} changePasswordRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authPasswordPatchFp = async (
  changePasswordRequestDto: ChangePasswordRequestDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePasswordResponseDto>> => {
  const localVarAxiosArgs = await authPasswordPatchAxiosParamCreator(changePasswordRequestDto, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 저장된 비밀번호가 맞는지 확인합니다.
 * @summary 비밀번호 확인
 * @param {PasswordDto} passwordDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authPasswordPostFp = async (
  passwordDto: PasswordDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> => {
  const localVarAxiosArgs = await authPasswordPostAxiosParamCreator(passwordDto, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * Refresh Token을 사용하여 Access Token과 Refresh Token을 재발급받습니다.
 * @summary Token 재발급
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authRefreshPostFp = async (
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtTokenDto>> => {
  const localVarAxiosArgs = await authRefreshPostAxiosParamCreator(options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 이메일로 인증번호를 발송합니다.
 * @summary 이메일 인증번호 발송
 * @param {VerificationRequestDto} verificationRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authRequestEmailVerificationPostFp = async (
  verificationRequestDto: VerificationRequestDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponseDto>> => {
  const localVarAxiosArgs = await authRequestEmailVerificationPostAxiosParamCreator(
    verificationRequestDto,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 유저정보를 생성하고 학교인증 요청을 발송합니다.
 * @summary 회원가입 및 학교인증 요청
 * @param {string} email 인증완료된 사용자 이메일
 * @param {string} password 사용자 비밀번호
 * @param {string} username 중복확인 완료된 userId
 * @param {string} name 본명
 * @param {string} country 국적
 * @param {string} homeUniversity 모교
 * @param {string} major 전공
 * @param {number} studentNumber 중복확인 완료된 학번
 * @param {any} screenshot 교환학생 합격 스크린샷 파일
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authSignUpPostFp = async (
  email: string,
  password: string,
  username: string,
  name: string,
  country: string,
  homeUniversity: string,
  major: string,
  studentNumber: number,
  screenshot: any,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponseDto>> => {
  const localVarAxiosArgs = await authSignUpPostAxiosParamCreator(
    email,
    password,
    username,
    name,
    country,
    homeUniversity,
    major,
    studentNumber,
    screenshot,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 요청한 학번으로 인증된 유저가 있는지 확인합니다.
 * @summary 학번 중복 확인
 * @param {number} studentNumber 중복확인하고자 하는 학번
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authStudentNumberStudentNumberPostFp = async (
  studentNumber: number,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPossibleResponseDto>> => {
  const localVarAxiosArgs = await authStudentNumberStudentNumberPostAxiosParamCreator(
    studentNumber,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 임시비밀번호를 발급하여 이메일로 발송합니다.
 * @summary 임시비밀번호 발급
 * @param {SendTempPasswordRequestDto} sendTempPasswordRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authTemporaryPasswordPostFp = async (
  sendTempPasswordRequestDto: SendTempPasswordRequestDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendTempPasswordResponseDto>> => {
  const localVarAxiosArgs = await authTemporaryPasswordPostAxiosParamCreator(
    sendTempPasswordRequestDto,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 요청한 username을 사용하는 유저가 있는지 확인합니다.
 * @summary username 중복 확인
 * @param {string} username 중복확인하고자 하는 username
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authUsernameUsernamePostFp = async (
  username: string,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPossibleResponseDto>> => {
  const localVarAxiosArgs = await authUsernameUsernamePostAxiosParamCreator(username, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 발송된 인증번호로 이메일을 인증합니다.
 * @summary 이메일 인증
 * @param {VerifyEmailRequestDto} verifyEmailRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const authVerifyEmailPostFp = async (
  verifyEmailRequestDto: VerifyEmailRequestDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyEmailResponseDto>> => {
  const localVarAxiosArgs = await authVerifyEmailPostAxiosParamCreator(verifyEmailRequestDto, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}

/**
 * AuthApi - factory interface
 * @export
 */

export type AuthAdminRequestGetRequestParams = {
  options?: any
}

/**
 * 승인 대기 중인 학교 인증 요청 목록을 조회합니다.
 * @summary 학교인증 요청 목록 조회
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authAdminRequestGet = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params?: { options?: any }): AxiosPromise<Array<GetScreenshotVerificationsResponseDto>> => {
    return authAdminRequestGetFp(params?.options, configuration).then(request => request(axios, basePath))
  }
}

export type AuthAdminRequestIdPostRequestParams = {
  id: number
  verifyScreenshotRequestDto: VerifyScreenshotRequestDto
  options?: any
}

/**
 * 학교 인증 요청을 승인 혹은 거절합니다.
 * @summary 학교인증 요청 승인/거절
 * @param {number} id
 * @param {VerifyScreenshotRequestDto} verifyScreenshotRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authAdminRequestIdPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthAdminRequestIdPostRequestParams): AxiosPromise<VerifyScreenshotResponseDto> => {
    return authAdminRequestIdPostFp(params.id, params.verifyScreenshotRequestDto, params.options, configuration).then(
      request => request(axios, basePath),
    )
  }
}

export type AuthEmailEmailPostRequestParams = {
  email: string
  options?: any
}

/**
 * 요청한 email을 사용하는 유저가 있는지 확인합니다.
 * @summary email 중복 확인
 * @param {string} email 중복확인하고자 하는 email
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authEmailEmailPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthEmailEmailPostRequestParams): AxiosPromise<CheckPossibleResponseDto> => {
    return authEmailEmailPostFp(params.email, params.options, configuration).then(request => request(axios, basePath))
  }
}

export type AuthIsVerifiedGetRequestParams = {
  options?: any
}

/**
 * 유저가 인증이 되었는지 확인합니다.
 * @summary 인증 여부 확인
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authIsVerifiedGet = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params?: { options?: any }): AxiosPromise<boolean> => {
    return authIsVerifiedGetFp(params?.options, configuration).then(request => request(axios, basePath))
  }
}

export type AuthLoginPostRequestParams = {
  loginRequestDto: LoginRequestDto
  options?: any
}

/**
 * 로그인하여 JWT Token을 발급받습니다.         Access Token의 만료기간은 5분이고 Refresh Token의 만료기간은 로그인 유지가 참일 경우 14일, 아닐 경우 2일입니다.
 * @summary 로그인
 * @param {LoginRequestDto} loginRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authLoginPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthLoginPostRequestParams): AxiosPromise<LoginResponseDto> => {
    return authLoginPostFp(params.loginRequestDto, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type AuthLogoutPostRequestParams = {
  logoutRequestDto: LogoutRequestDto
  options?: any
}

/**
 * 서버에 저장된 Refresh Token을 삭제합니다.
 * @summary 로그아웃
 * @param {LogoutRequestDto} logoutRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authLogoutPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthLogoutPostRequestParams): AxiosPromise<LogoutResponseDto> => {
    return authLogoutPostFp(params.logoutRequestDto, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type AuthPasswordPatchRequestParams = {
  changePasswordRequestDto: ChangePasswordRequestDto
  options?: any
}

/**
 * 사용자의 비밀번호를 변경합니다.
 * @summary 비밀번호 변경
 * @param {ChangePasswordRequestDto} changePasswordRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authPasswordPatch = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthPasswordPatchRequestParams): AxiosPromise<ChangePasswordResponseDto> => {
    return authPasswordPatchFp(params.changePasswordRequestDto, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type AuthPasswordPostRequestParams = {
  passwordDto: PasswordDto
  options?: any
}

/**
 * 저장된 비밀번호가 맞는지 확인합니다.
 * @summary 비밀번호 확인
 * @param {PasswordDto} passwordDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authPasswordPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthPasswordPostRequestParams): AxiosPromise<boolean> => {
    return authPasswordPostFp(params.passwordDto, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type AuthRefreshPostRequestParams = {
  options?: any
}

/**
 * Refresh Token을 사용하여 Access Token과 Refresh Token을 재발급받습니다.
 * @summary Token 재발급
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authRefreshPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params?: { options?: any }): AxiosPromise<JwtTokenDto> => {
    return authRefreshPostFp(params?.options, configuration).then(request => request(axios, basePath))
  }
}

export type AuthRequestEmailVerificationPostRequestParams = {
  verificationRequestDto: VerificationRequestDto
  options?: any
}

/**
 * 이메일로 인증번호를 발송합니다.
 * @summary 이메일 인증번호 발송
 * @param {VerificationRequestDto} verificationRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authRequestEmailVerificationPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthRequestEmailVerificationPostRequestParams): AxiosPromise<VerificationResponseDto> => {
    return authRequestEmailVerificationPostFp(params.verificationRequestDto, params.options, configuration).then(
      request => request(axios, basePath),
    )
  }
}

export type AuthSignUpPostRequestParams = {
  email: string
  password: string
  username: string
  name: string
  country: string
  homeUniversity: string
  major: string
  studentNumber: number
  screenshot: any
  options?: any
}

/**
 * 유저정보를 생성하고 학교인증 요청을 발송합니다.
 * @summary 회원가입 및 학교인증 요청
 * @param {string} email 인증완료된 사용자 이메일
 * @param {string} password 사용자 비밀번호
 * @param {string} username 중복확인 완료된 userId
 * @param {string} name 본명
 * @param {string} country 국적
 * @param {string} homeUniversity 모교
 * @param {string} major 전공
 * @param {number} studentNumber 중복확인 완료된 학번
 * @param {any} screenshot 교환학생 합격 스크린샷 파일
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authSignUpPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthSignUpPostRequestParams): AxiosPromise<SignUpResponseDto> => {
    return authSignUpPostFp(
      params.email,
      params.password,
      params.username,
      params.name,
      params.country,
      params.homeUniversity,
      params.major,
      params.studentNumber,
      params.screenshot,
      params.options,
      configuration,
    ).then(request => request(axios, basePath))
  }
}

export type AuthStudentNumberStudentNumberPostRequestParams = {
  studentNumber: number
  options?: any
}

/**
 * 요청한 학번으로 인증된 유저가 있는지 확인합니다.
 * @summary 학번 중복 확인
 * @param {number} studentNumber 중복확인하고자 하는 학번
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authStudentNumberStudentNumberPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthStudentNumberStudentNumberPostRequestParams): AxiosPromise<CheckPossibleResponseDto> => {
    return authStudentNumberStudentNumberPostFp(params.studentNumber, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type AuthTemporaryPasswordPostRequestParams = {
  sendTempPasswordRequestDto: SendTempPasswordRequestDto
  options?: any
}

/**
 * 임시비밀번호를 발급하여 이메일로 발송합니다.
 * @summary 임시비밀번호 발급
 * @param {SendTempPasswordRequestDto} sendTempPasswordRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authTemporaryPasswordPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthTemporaryPasswordPostRequestParams): AxiosPromise<SendTempPasswordResponseDto> => {
    return authTemporaryPasswordPostFp(params.sendTempPasswordRequestDto, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type AuthUsernameUsernamePostRequestParams = {
  username: string
  options?: any
}

/**
 * 요청한 username을 사용하는 유저가 있는지 확인합니다.
 * @summary username 중복 확인
 * @param {string} username 중복확인하고자 하는 username
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authUsernameUsernamePost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthUsernameUsernamePostRequestParams): AxiosPromise<CheckPossibleResponseDto> => {
    return authUsernameUsernamePostFp(params.username, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type AuthVerifyEmailPostRequestParams = {
  verifyEmailRequestDto: VerifyEmailRequestDto
  options?: any
}

/**
 * 발송된 인증번호로 이메일을 인증합니다.
 * @summary 이메일 인증
 * @param {VerifyEmailRequestDto} verifyEmailRequestDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const authVerifyEmailPost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: AuthVerifyEmailPostRequestParams): AxiosPromise<VerifyEmailResponseDto> => {
    return authVerifyEmailPostFp(params.verifyEmailRequestDto, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export const getauthAdminRequestGetPath = () => {
  return `/auth/admin/request`
}
export const getauthAdminRequestIdPostPath = (id: number, verifyScreenshotRequestDto: VerifyScreenshotRequestDto) => {
  return `/auth/admin/request/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
}
export const getauthEmailEmailPostPath = (email: string) => {
  return `/auth/email/{email}`.replace(`{${'email'}}`, encodeURIComponent(String(email)))
}
export const getauthIsVerifiedGetPath = () => {
  return `/auth/is-verified`
}
export const getauthLoginPostPath = (loginRequestDto: LoginRequestDto) => {
  return `/auth/login`
}
export const getauthLogoutPostPath = (logoutRequestDto: LogoutRequestDto) => {
  return `/auth/logout`
}
export const getauthPasswordPatchPath = (changePasswordRequestDto: ChangePasswordRequestDto) => {
  return `/auth/password`
}
export const getauthPasswordPostPath = (passwordDto: PasswordDto) => {
  return `/auth/password`
}
export const getauthRefreshPostPath = () => {
  return `/auth/refresh`
}
export const getauthRequestEmailVerificationPostPath = (verificationRequestDto: VerificationRequestDto) => {
  return `/auth/request-email-verification`
}
export const getauthSignUpPostPath = (
  email: string,
  password: string,
  username: string,
  name: string,
  country: string,
  homeUniversity: string,
  major: string,
  studentNumber: number,
  screenshot: any,
) => {
  return `/auth/sign-up`
}
export const getauthStudentNumberStudentNumberPostPath = (studentNumber: number) => {
  return `/auth/student-number/{studentNumber}`.replace(
    `{${'studentNumber'}}`,
    encodeURIComponent(String(studentNumber)),
  )
}
export const getauthTemporaryPasswordPostPath = (sendTempPasswordRequestDto: SendTempPasswordRequestDto) => {
  return `/auth/temporary-password`
}
export const getauthUsernameUsernamePostPath = (username: string) => {
  return `/auth/username/{username}`.replace(`{${'username'}}`, encodeURIComponent(String(username)))
}
export const getauthVerifyEmailPostPath = (verifyEmailRequestDto: VerifyEmailRequestDto) => {
  return `/auth/verify-email`
}
