/* tslint:disable */
/* eslint-disable */
/**
 * KU-KEY API
 * API for KU-KEY service
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import { Configuration } from '../configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, toPathString, createRequestFunction } from '../common'
// @ts-ignore
import { COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base'

// @ts-ignore
import { CommonDeleteResponseDto } from '../models'
// @ts-ignore
import { CommonTimetableResponseDto } from '../models'
// @ts-ignore
import { CreateTimetableCourseResponseDto } from '../models'
// @ts-ignore
import { CreateTimetableDto } from '../models'
// @ts-ignore
import { GetTimetableByTimetableIdDto } from '../models'
// @ts-ignore
import { GetTimetableByUserIdResponseDto } from '../models'
// @ts-ignore
import { TimetableDto } from '../models'
// @ts-ignore
import { UpdateTimetableColorDto } from '../models'
// @ts-ignore
import { UpdateTimetableNameDto } from '../models'
/**
 * TimetableApi - axios parameter creator
 * @export
 */
/**
 * 특정 시간표의 색상을 변경합니다.
 * @summary 시간표 색상 변경
 * @param {number} timetableId 변경할 시간표 ID
 * @param {UpdateTimetableColorDto} updateTimetableColorDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableColorTimetableIdPatchAxiosParamCreator = async (
  timetableId: number,
  updateTimetableColorDto: UpdateTimetableColorDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/color/{timetableId}`.replace(
    `{${'timetableId'}}`,
    encodeURIComponent(String(timetableId)),
  )
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = updateTimetableColorDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 해당 시간표에 등록한 특정 강의를 삭제합니다.
 * @summary 시간표에 등록한 강의 삭제
 * @param {number} timetableId 특정 시간표 ID
 * @param {number} courseId 삭제할 강의 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableCourseDeleteAxiosParamCreator = async (
  timetableId: number,
  courseId: number,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/course`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any
  if (timetableId !== undefined) {
    localVarQueryParameter['timetableId'] = timetableId
  }

  if (courseId !== undefined) {
    localVarQueryParameter['courseId'] = courseId
  }

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 시간표에 특정 강의를 추가합니다. 해당 시간에 이미 등록된 개인 스케쥴이나 강의가 있을 경우 추가되지 않습니다.
 * @summary 시간표에 강의 추가
 * @param {number} timetableId 특정 시간표 ID
 * @param {number} courseId 추가할 강의 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableCoursePostAxiosParamCreator = async (
  timetableId: number,
  courseId: number,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/course`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any
  if (timetableId !== undefined) {
    localVarQueryParameter['timetableId'] = timetableId
  }

  if (courseId !== undefined) {
    localVarQueryParameter['courseId'] = courseId
  }

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 해당 유저의 대표 시간표를 조회합니다.
 * @summary 대표 시간표 조회
 * @param {string} semester 학기
 * @param {string} year 연도
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableMainTimetableGetAxiosParamCreator = async (
  semester: string,
  year: string,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/main-timetable`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any
  if (semester !== undefined) {
    localVarQueryParameter['semester'] = semester
  }

  if (year !== undefined) {
    localVarQueryParameter['year'] = year
  }

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 특정 시간표의 이름을 변경합니다.
 * @summary 시간표 이름 변경
 * @param {number} timetableId 변경할 시간표 ID
 * @param {UpdateTimetableNameDto} updateTimetableNameDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableNameTimetableIdPatchAxiosParamCreator = async (
  timetableId: number,
  updateTimetableNameDto: UpdateTimetableNameDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/name/{timetableId}`.replace(
    `{${'timetableId'}}`,
    encodeURIComponent(String(timetableId)),
  )
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = updateTimetableNameDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 해당 연도, 학기에 시간표를 생성합니다. 처음 만들어진 시간표가 대표시간표가 되며, 한 학기에 최대 3개까지 시간표 생성이 가능합니다.
 * @summary 시간표 생성
 * @param {CreateTimetableDto} createTimetableDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetablePostAxiosParamCreator = async (
  createTimetableDto: CreateTimetableDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = createTimetableDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 특정 시간표를 삭제합니다. 삭제 시 해당 시간표에 등록된 모든 강의도 삭제됩니다.
 * @summary 시간표 삭제
 * @param {number} timetableId 삭제할 시간표 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableTimetableIdDeleteAxiosParamCreator = async (
  timetableId: number,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/{timetableId}`.replace(`{${'timetableId'}}`, encodeURIComponent(String(timetableId)))
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 시간표 ID로 해당 시간표와 관련된 강의,일정 정보를 반환합니다.
 * @summary 시간표 ID로 시간표 관련 정보 조회
 * @param {number} timetableId 특정 시간표 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableTimetableIdGetAxiosParamCreator = async (
  timetableId: number,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/{timetableId}`.replace(`{${'timetableId'}}`, encodeURIComponent(String(timetableId)))
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 특정 시간표를 대표 시간표로 변경합니다. 기존에 이미 대표시간표이면 변경되지 않습니다.
 * @summary 대표 시간표 변경
 * @param {number} timetableId 대표 시간표로 변경할 시간표 ID
 * @param {TimetableDto} timetableDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableTimetableIdPatchAxiosParamCreator = async (
  timetableId: number,
  timetableDto: TimetableDto,
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/{timetableId}`.replace(`{${'timetableId'}}`, encodeURIComponent(String(timetableId)))
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  localVarHeaderParameter['Content-Type'] = 'application/json'

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
  localVarRequestOptions.data = timetableDto || undefined

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}
/**
 * 해당 유저가 가지고 있는 시간표의 ID 리스트, 각각의 학기, 대표 시간표 여부, 시간표 이름을 반환합니다.
 * @summary 유저의 ID로 시간표 관련 정보 조회
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableUserGetAxiosParamCreator = async (
  options: AxiosRequestConfig = {},
  configuration?: Configuration,
): Promise<RequestArgs> => {
  const localVarPath = `/timetable/user`
  // use dummy base URL string because the URL constructor only accepts absolute URLs.
  const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
  let baseOptions
  if (configuration) {
    baseOptions = configuration.baseOptions
  }

  const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
  const localVarHeaderParameter = {} as any
  const localVarQueryParameter = {} as any

  setSearchParams(localVarUrlObj, localVarQueryParameter)
  let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
  localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

  return {
    url: toPathString(localVarUrlObj),
    options: localVarRequestOptions,
  }
}

/**
 * TimetableApi - functional programming interface
 * @export
 */
/**
 * 특정 시간표의 색상을 변경합니다.
 * @summary 시간표 색상 변경
 * @param {number} timetableId 변경할 시간표 ID
 * @param {UpdateTimetableColorDto} updateTimetableColorDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableColorTimetableIdPatchFp = async (
  timetableId: number,
  updateTimetableColorDto: UpdateTimetableColorDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonTimetableResponseDto>> => {
  const localVarAxiosArgs = await timetableColorTimetableIdPatchAxiosParamCreator(
    timetableId,
    updateTimetableColorDto,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 해당 시간표에 등록한 특정 강의를 삭제합니다.
 * @summary 시간표에 등록한 강의 삭제
 * @param {number} timetableId 특정 시간표 ID
 * @param {number} courseId 삭제할 강의 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableCourseDeleteFp = async (
  timetableId: number,
  courseId: number,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonDeleteResponseDto>> => {
  const localVarAxiosArgs = await timetableCourseDeleteAxiosParamCreator(timetableId, courseId, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 시간표에 특정 강의를 추가합니다. 해당 시간에 이미 등록된 개인 스케쥴이나 강의가 있을 경우 추가되지 않습니다.
 * @summary 시간표에 강의 추가
 * @param {number} timetableId 특정 시간표 ID
 * @param {number} courseId 추가할 강의 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableCoursePostFp = async (
  timetableId: number,
  courseId: number,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTimetableCourseResponseDto>> => {
  const localVarAxiosArgs = await timetableCoursePostAxiosParamCreator(timetableId, courseId, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 해당 유저의 대표 시간표를 조회합니다.
 * @summary 대표 시간표 조회
 * @param {string} semester 학기
 * @param {string} year 연도
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableMainTimetableGetFp = async (
  semester: string,
  year: string,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonTimetableResponseDto>> => {
  const localVarAxiosArgs = await timetableMainTimetableGetAxiosParamCreator(semester, year, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 특정 시간표의 이름을 변경합니다.
 * @summary 시간표 이름 변경
 * @param {number} timetableId 변경할 시간표 ID
 * @param {UpdateTimetableNameDto} updateTimetableNameDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableNameTimetableIdPatchFp = async (
  timetableId: number,
  updateTimetableNameDto: UpdateTimetableNameDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonTimetableResponseDto>> => {
  const localVarAxiosArgs = await timetableNameTimetableIdPatchAxiosParamCreator(
    timetableId,
    updateTimetableNameDto,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 해당 연도, 학기에 시간표를 생성합니다. 처음 만들어진 시간표가 대표시간표가 되며, 한 학기에 최대 3개까지 시간표 생성이 가능합니다.
 * @summary 시간표 생성
 * @param {CreateTimetableDto} createTimetableDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetablePostFp = async (
  createTimetableDto: CreateTimetableDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonTimetableResponseDto>> => {
  const localVarAxiosArgs = await timetablePostAxiosParamCreator(createTimetableDto, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 특정 시간표를 삭제합니다. 삭제 시 해당 시간표에 등록된 모든 강의도 삭제됩니다.
 * @summary 시간표 삭제
 * @param {number} timetableId 삭제할 시간표 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableTimetableIdDeleteFp = async (
  timetableId: number,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonDeleteResponseDto>> => {
  const localVarAxiosArgs = await timetableTimetableIdDeleteAxiosParamCreator(timetableId, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 시간표 ID로 해당 시간표와 관련된 강의,일정 정보를 반환합니다.
 * @summary 시간표 ID로 시간표 관련 정보 조회
 * @param {number} timetableId 특정 시간표 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableTimetableIdGetFp = async (
  timetableId: number,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimetableByTimetableIdDto>> => {
  const localVarAxiosArgs = await timetableTimetableIdGetAxiosParamCreator(timetableId, options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 특정 시간표를 대표 시간표로 변경합니다. 기존에 이미 대표시간표이면 변경되지 않습니다.
 * @summary 대표 시간표 변경
 * @param {number} timetableId 대표 시간표로 변경할 시간표 ID
 * @param {TimetableDto} timetableDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableTimetableIdPatchFp = async (
  timetableId: number,
  timetableDto: TimetableDto,
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommonTimetableResponseDto>> => {
  const localVarAxiosArgs = await timetableTimetableIdPatchAxiosParamCreator(
    timetableId,
    timetableDto,
    options,
    configuration,
  )
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}
/**
 * 해당 유저가 가지고 있는 시간표의 ID 리스트, 각각의 학기, 대표 시간표 여부, 시간표 이름을 반환합니다.
 * @summary 유저의 ID로 시간표 관련 정보 조회
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
const timetableUserGetFp = async (
  options?: AxiosRequestConfig,
  configuration?: Configuration,
): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTimetableByUserIdResponseDto>>> => {
  const localVarAxiosArgs = await timetableUserGetAxiosParamCreator(options, configuration)
  return createRequestFunction(localVarAxiosArgs, globalAxios, configuration)
}

/**
 * TimetableApi - factory interface
 * @export
 */

export type TimetableColorTimetableIdPatchRequestParams = {
  timetableId: number
  updateTimetableColorDto: UpdateTimetableColorDto
  options?: any
}

/**
 * 특정 시간표의 색상을 변경합니다.
 * @summary 시간표 색상 변경
 * @param {number} timetableId 변경할 시간표 ID
 * @param {UpdateTimetableColorDto} updateTimetableColorDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableColorTimetableIdPatch = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableColorTimetableIdPatchRequestParams): AxiosPromise<CommonTimetableResponseDto> => {
    return timetableColorTimetableIdPatchFp(
      params.timetableId,
      params.updateTimetableColorDto,
      params.options,
      configuration,
    ).then(request => request(axios, basePath))
  }
}

export type TimetableCourseDeleteRequestParams = {
  timetableId: number
  courseId: number
  options?: any
}

/**
 * 해당 시간표에 등록한 특정 강의를 삭제합니다.
 * @summary 시간표에 등록한 강의 삭제
 * @param {number} timetableId 특정 시간표 ID
 * @param {number} courseId 삭제할 강의 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableCourseDelete = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableCourseDeleteRequestParams): AxiosPromise<CommonDeleteResponseDto> => {
    return timetableCourseDeleteFp(params.timetableId, params.courseId, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type TimetableCoursePostRequestParams = {
  timetableId: number
  courseId: number
  options?: any
}

/**
 * 시간표에 특정 강의를 추가합니다. 해당 시간에 이미 등록된 개인 스케쥴이나 강의가 있을 경우 추가되지 않습니다.
 * @summary 시간표에 강의 추가
 * @param {number} timetableId 특정 시간표 ID
 * @param {number} courseId 추가할 강의 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableCoursePost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableCoursePostRequestParams): AxiosPromise<CreateTimetableCourseResponseDto> => {
    return timetableCoursePostFp(params.timetableId, params.courseId, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type TimetableMainTimetableGetRequestParams = {
  semester: string
  year: string
  options?: any
}

/**
 * 해당 유저의 대표 시간표를 조회합니다.
 * @summary 대표 시간표 조회
 * @param {string} semester 학기
 * @param {string} year 연도
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableMainTimetableGet = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableMainTimetableGetRequestParams): AxiosPromise<CommonTimetableResponseDto> => {
    return timetableMainTimetableGetFp(params.semester, params.year, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type TimetableNameTimetableIdPatchRequestParams = {
  timetableId: number
  updateTimetableNameDto: UpdateTimetableNameDto
  options?: any
}

/**
 * 특정 시간표의 이름을 변경합니다.
 * @summary 시간표 이름 변경
 * @param {number} timetableId 변경할 시간표 ID
 * @param {UpdateTimetableNameDto} updateTimetableNameDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableNameTimetableIdPatch = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableNameTimetableIdPatchRequestParams): AxiosPromise<CommonTimetableResponseDto> => {
    return timetableNameTimetableIdPatchFp(
      params.timetableId,
      params.updateTimetableNameDto,
      params.options,
      configuration,
    ).then(request => request(axios, basePath))
  }
}

export type TimetablePostRequestParams = {
  createTimetableDto: CreateTimetableDto
  options?: any
}

/**
 * 해당 연도, 학기에 시간표를 생성합니다. 처음 만들어진 시간표가 대표시간표가 되며, 한 학기에 최대 3개까지 시간표 생성이 가능합니다.
 * @summary 시간표 생성
 * @param {CreateTimetableDto} createTimetableDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetablePost = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetablePostRequestParams): AxiosPromise<CommonTimetableResponseDto> => {
    return timetablePostFp(params.createTimetableDto, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type TimetableTimetableIdDeleteRequestParams = {
  timetableId: number
  options?: any
}

/**
 * 특정 시간표를 삭제합니다. 삭제 시 해당 시간표에 등록된 모든 강의도 삭제됩니다.
 * @summary 시간표 삭제
 * @param {number} timetableId 삭제할 시간표 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableTimetableIdDelete = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableTimetableIdDeleteRequestParams): AxiosPromise<CommonDeleteResponseDto> => {
    return timetableTimetableIdDeleteFp(params.timetableId, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type TimetableTimetableIdGetRequestParams = {
  timetableId: number
  options?: any
}

/**
 * 시간표 ID로 해당 시간표와 관련된 강의,일정 정보를 반환합니다.
 * @summary 시간표 ID로 시간표 관련 정보 조회
 * @param {number} timetableId 특정 시간표 ID
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableTimetableIdGet = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableTimetableIdGetRequestParams): AxiosPromise<GetTimetableByTimetableIdDto> => {
    return timetableTimetableIdGetFp(params.timetableId, params.options, configuration).then(request =>
      request(axios, basePath),
    )
  }
}

export type TimetableTimetableIdPatchRequestParams = {
  timetableId: number
  timetableDto: TimetableDto
  options?: any
}

/**
 * 특정 시간표를 대표 시간표로 변경합니다. 기존에 이미 대표시간표이면 변경되지 않습니다.
 * @summary 대표 시간표 변경
 * @param {number} timetableId 대표 시간표로 변경할 시간표 ID
 * @param {TimetableDto} timetableDto
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableTimetableIdPatch = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params: TimetableTimetableIdPatchRequestParams): AxiosPromise<CommonTimetableResponseDto> => {
    return timetableTimetableIdPatchFp(params.timetableId, params.timetableDto, params.options, configuration).then(
      request => request(axios, basePath),
    )
  }
}

export type TimetableUserGetRequestParams = {
  options?: any
}

/**
 * 해당 유저가 가지고 있는 시간표의 ID 리스트, 각각의 학기, 대표 시간표 여부, 시간표 이름을 반환합니다.
 * @summary 유저의 ID로 시간표 관련 정보 조회
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 */
export const timetableUserGet = ({
  configuration,
  basePath,
  axios,
}: {
  configuration?: Configuration
  basePath?: string
  axios?: AxiosInstance
}) => {
  return (params?: { options?: any }): AxiosPromise<Array<GetTimetableByUserIdResponseDto>> => {
    return timetableUserGetFp(params?.options, configuration).then(request => request(axios, basePath))
  }
}
